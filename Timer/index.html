<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Broadcast Timer</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #121212;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
            overflow: hidden;
            user-select: none; /* Prevent selection like a native app */
        }

        #timer-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            font-weight: bold;
            font-family: "黑体", SimHei, sans-serif;
            color: #00FF88;
            padding-top: 0;
            line-height: 1;
        }
        #timer-text {
            display: inline-block;
            white-space: nowrap;
            font-size: 18vw;
        }
        #timer-text .digit {
            font-family: 'Courier New', Courier, monospace;
            font-variant-numeric: tabular-nums;
            font-feature-settings: "tnum" 1, "zero" 0;
        }
        #timer-text .colon {
            font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
            font-variant-numeric: normal;
            font-feature-settings: "tnum" 0;
            letter-spacing: -0.02em;
        }

        #bottom-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
        }

        #local-time {
            font-size: 10vh;
            color: #FFFFFF;
            margin-bottom: 2vh;
            font-family: "Segoe UI", sans-serif;
        }

        #controls-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #controls {
            background-color: #121212;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: white;
            font-size: 1.5rem;
            flex-wrap: wrap;
        }
        #connect {
            background-color: #121212;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: white;
            width: 100%;
            max-width: 1000px;
        }
        #connect input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            font-family: "Segoe UI", sans-serif;
        }

        .control-label {
            font-size: 1.2rem;
        }

        input {
            background-color: #FFFFFF;
            border: none;
            font-size: 1.2rem;
            padding: 5px;
            width: 120px;
            text-align: center;
            font-family: "Segoe UI", sans-serif;
        }

        button {
            background-color: #1F1F1F;
            color: #FFFFFF;
            border: none;
            padding: 10px 20px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: 80px;
        }

        button:hover {
            background-color: #2E2E2E;
        }

        button:active {
            background-color: #3E3E3E;
        }

        #status {
            color: #FF6666;
            height: 1.5rem;
            margin-top: 5px;
            font-size: 1rem;
        }

        /* Helper classes */
        .text-green { color: #00FF88 !important; }
        .text-red { color: #FF4444 !important; }
        .text-hidden { color: #121212 !important; } /* Match bg to hide */

    </style>
</head>
<body>

    <div id="timer-container"><span id="timer-text">00:10:00</span></div>

    <div id="bottom-container">
        <div id="local-time">00:00:00</div>
        
        <div id="controls-wrapper">
            <div id="controls">
                <span class="control-label">Set Timer<br>(HH:MM:SS):</span>
                <input type="text" id="time-input" value="00:10:00">
                <button id="btn-start">Start</button>
                <button id="btn-reset">Reset</button>
                <button id="btn-set">Set</button>
                <button id="btn-fullscreen">Fullscreen</button>
                <button id="btn-toggle-connect">跨设备</button>
                <input type="text" id="room-id" placeholder="房间号" style="width:120px">
                <button id="btn-auto-connect">自动连接</button>
            </div>
            <div id="status"></div>
        </div>
    </div>

    <!-- Audio element -->
    <audio id="notify-sound" src="notify.wav" preload="auto"></audio>

    <script>
        // --- State ---
        let timerRunning = false;
        let remainingSeconds = 600; // Default 10 mins
        let remainingSecondsLastTick = 600;
        let targetTime = null;
        let timerInterval = null;
        let flashInterval = null;
        let flashState = false;
        let bcSync = null;
        
        // --- DOM Elements ---
        const timerLabel = document.getElementById('timer-container');
        const timerText = document.getElementById('timer-text');
        const localTimeLabel = document.getElementById('local-time');
        const timeInput = document.getElementById('time-input');
        const btnStart = document.getElementById('btn-start');
        const btnFullscreen = document.getElementById('btn-fullscreen');
        const statusLabel = document.getElementById('status');
        const notifySound = document.getElementById('notify-sound');
        const btnGenAnswer = null;
        let pc = null;
        let dc = null;
        let pcIceDone = false;
        let pendingCandidates = [];
        const roomInput = document.getElementById('room-id');
        const btnAutoConnect = document.getElementById('btn-auto-connect');

        // --- Initialization ---
        function init() {
            try {
                bcSync = new BroadcastChannel('timer-sync');
                bcSync.onmessage = onSyncMessage;
            } catch (e) {
                bcSync = null;
            }
            updateLocalTime();
            setInterval(updateLocalTime, 1000);
            fitTimerToWidth();
            window.addEventListener('resize', fitTimerToWidth);
            
            // Event Listeners
            document.getElementById('btn-start').addEventListener('click', toggleTimer);
            document.getElementById('btn-reset').addEventListener('click', resetTimer);
            document.getElementById('btn-set').addEventListener('click', setTimer);
            btnFullscreen.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', () => {
                btnFullscreen.textContent = document.fullscreenElement ? "Exit Fullscreen" : "Fullscreen";
            });
            btnFullscreen.textContent = document.fullscreenElement ? "Exit Fullscreen" : "Fullscreen";
            
            // Initial render
            renderTimeText(formatSeconds(remainingSeconds));
            fitTimerToWidth();
            broadcastStatus();
            initWebRTCUI();
            // Default room from URL
            const urlParams = new URLSearchParams(window.location.search);
            const rid = urlParams.get('room') || '';
            const encodedOffer = urlParams.get('offer') || '';
            if (rid) roomInput.value = rid;
            if (!roomInput.value) roomInput.value = Math.random().toString().slice(2,8);
            btnAutoConnect.addEventListener('click', autoConnectAnswerer);
            // Auto-connect if room provided via URL
            if (rid) setTimeout(autoConnectAnswerer, 0);
            // 若 URL 携带 Offer，自动填充并尝试连接
            if (encodedOffer) {
                try {
                    const offer = JSON.parse(atob(decodeURIComponent(encodedOffer)));
                    document.getElementById('offer-input').value = JSON.stringify(offer);
                    setTimeout(() => {
                        document.getElementById('btn-accept-offer').click();
                    }, 0);
                } catch(e){
                    statusLabel.textContent = 'URL Offer 解析失败';
                }
            }
        }

        // --- Logic ---

        function updateLocalTime() {
            const now = new Date();
            const h = String(now.getHours()).padStart(2, '0');
            const m = String(now.getMinutes()).padStart(2, '0');
            const s = String(now.getSeconds()).padStart(2, '0');
            localTimeLabel.textContent = `${h}:${m}:${s}`;
        }

        function formatSeconds(totalSeconds) {
            const safeSeconds = Math.max(totalSeconds, 0);
            const hours = Math.floor(safeSeconds / 3600);
            const minutes = Math.floor((safeSeconds % 3600) / 60);
            const seconds = safeSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function parseInputTime(text) {
            const parts = text.trim().split(':');
            if (parts.length !== 3) return null;
            const h = parseInt(parts[0], 10);
            const m = parseInt(parts[1], 10);
            const s = parseInt(parts[2], 10);

            if (isNaN(h) || isNaN(m) || isNaN(s)) return null;
            if (m < 0 || m >= 60 || s < 0 || s >= 60 || h < 0 || h > 99) return null;
            
            return h * 3600 + m * 60 + s;
        }

        function toggleTimer() {
            // User interaction unlocks audio
            unlockAudio();

            if (!timerRunning) {
                if (remainingSeconds <= 0) {
                    if (!setTimer()) return;
                }
                beginCountdown();
            } else {
                pauseTimer();
            }
        }

        function beginCountdown() {
            stopFlash();
            const now = new Date();
            targetTime = new Date(now.getTime() + remainingSeconds * 1000);
            timerRunning = true;
            btnStart.textContent = "Pause";
            statusLabel.textContent = "";
            
            // Use requestAnimationFrame or setInterval for loop
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(tickTimer, 50); // 20ms in python, 50ms is enough here
        }

        function pauseTimer() {
            remainingSeconds = calculateRemainingSeconds();
            remainingSecondsLastTick = remainingSeconds;
            
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerRunning = false;
            btnStart.textContent = "Start";
        }

        function tickTimer() {
            const prev = remainingSeconds;
            const currentRemaining = calculateRemainingSeconds();
            
            // Check for 1 minute crossing
            // Python logic: if last > 60 and current <= 60
            const crossOneMinute = (remainingSecondsLastTick > 60 && currentRemaining <= 60);
            
            remainingSeconds = currentRemaining;
            remainingSecondsLastTick = currentRemaining;
            
            renderTimeText(formatSeconds(remainingSeconds));
            if (Math.floor(prev) !== Math.floor(currentRemaining)) {
                fitTimerToWidth();
                broadcastStatus();
            }

            if (remainingSeconds <= 0) {
                handleTimeExpired();
                return;
            }

            if (crossOneMinute) {
                timerText.classList.remove('text-green');
                timerText.classList.add('text-red');
                playAudio(2); // Play 2 times
            }
        }

        function calculateRemainingSeconds() {
            if (!targetTime) return Math.max(remainingSeconds, 0);
            const now = new Date();
            const diff = targetTime - now; // milliseconds
            if (diff <= 0) return 0;
            return Math.ceil(diff / 1000);
        }

        function handleTimeExpired() {
            remainingSeconds = 0;
            remainingSecondsLastTick = 0;
            timerRunning = false;
            targetTime = null;
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            btnStart.textContent = "Start";
            startFlash();
            fitTimerToWidth();
            broadcastStatus();
        }

        function startFlash() {
            if (flashInterval) return;
            
            timerText.textContent = "时 间 到";
            flashState = false;
            playAudio(3); // Play 3 times
            
            flashTimerLabel(); // Run once immediately? No, python uses .after(500)
            flashInterval = setInterval(flashTimerLabel, 500);
        }

        function flashTimerLabel() {
            flashState = !flashState;
            // Toggle between red and hidden (background color)
            // Python: fg_color = "#FF4444" if self.flash_state else "#121212"
            if (flashState) {
                timerText.classList.remove('text-hidden');
                timerText.classList.add('text-red');
            } else {
                timerText.classList.remove('text-red');
                timerText.classList.add('text-hidden');
            }
        }

        function stopFlash() {
            if (flashInterval) {
                clearInterval(flashInterval);
                flashInterval = null;
            }
            stopAudio();
            // Reset color
            timerText.classList.remove('text-red', 'text-hidden');
            timerText.classList.add('text-green');
            
            // If text was "Time's Up", reset it to time
            if (timerText.textContent === "时 间 到") {
                timerText.textContent = formatSeconds(remainingSeconds);
            }
        }

        function resetTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            timerRunning = false;
            btnStart.textContent = "Start";
            
            let secs = parseInputTime(timeInput.value);
            if (secs === null) secs = 600; // Default 10 mins

            remainingSeconds = secs;
            remainingSecondsLastTick = secs;
            targetTime = null;
            
            stopFlash();
            renderTimeText(formatSeconds(remainingSeconds));
            timeInput.value = formatSeconds(remainingSeconds); // Normalize input
            statusLabel.textContent = "Timer reset.";
            broadcastStatus();
        }

        function setTimer() {
            const secs = parseInputTime(timeInput.value);
            if (secs === null) {
                statusLabel.textContent = "Invalid time. Use HH:MM:SS.";
                return false;
            }

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            if (timerRunning) {
                timerRunning = false;
                btnStart.textContent = "Start";
            }

            stopFlash();
            remainingSeconds = secs;
            remainingSecondsLastTick = secs;
            renderTimeText(formatSeconds(remainingSeconds));
            targetTime = null;
            statusLabel.textContent = `Timer set to ${formatSeconds(remainingSeconds)}.`;
            fitTimerToWidth();
            broadcastStatus();
            return true;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(() => {});
                }
            }
        }

        // --- Audio Handling ---
        
        let audioPlayCount = 0;
        let audioTargetCount = 0;

        function unlockAudio() {
            // Try to play and pause immediately to unlock AudioContext on mobile/strict browsers
            // Just accessing the element in a click handler is usually enough for subsequent plays
            // We verify if we can play
            if (notifySound.paused) {
                 // notifySound.play().then(() => notifySound.pause()).catch(() => {});
            }
        }

        function playAudio(times) {
            audioTargetCount = times;
            audioPlayCount = 0;
            notifySound.currentTime = 0;
            
            // Remove previous listeners to avoid stacking
            notifySound.onended = null; 
            
            notifySound.onended = function() {
                audioPlayCount++;
                if (audioPlayCount < audioTargetCount) {
                    notifySound.currentTime = 0;
                    notifySound.play().catch(e => console.error(e));
                }
            };
            
            notifySound.play().catch(e => console.error("Audio play failed", e));
        }

        function stopAudio() {
            notifySound.pause();
            notifySound.currentTime = 0;
            notifySound.onended = null;
        }

        function fitTimerToWidth() {
            const target = Math.max(document.documentElement.clientWidth - 4, 320);
            timerText.style.fontSize = '100px';
            let measured = timerText.scrollWidth;
            let size = Math.max(Math.floor(100 * target / measured), 10);
            timerText.style.fontSize = size + 'px';
            measured = timerText.scrollWidth;
            if (measured < target) {
                size = Math.floor(size * target / measured);
                timerText.style.fontSize = size + 'px';
            }
        }
        function renderTimeText(hms) {
            timerText.innerHTML = hms
              .replace(/:/g, "<span class='colon'>:</span>")
              .replace(/\d/g, d => "<span class='digit'>" + d + "</span>");
        }
        function broadcastStatus() {
            if (!bcSync) return;
            bcSync.postMessage({
                type: 'status',
                running: timerRunning,
                remaining: Math.max(remainingSeconds, 0),
                timestamp: Date.now()
            });
            if (dc && dc.readyState === 'open') {
                try {
                    dc.send(JSON.stringify({type:'status',running:timerRunning,remaining:Math.max(remainingSeconds,0)}));
                } catch(e){}
            }
        }
        function onSyncMessage(ev) {
            const msg = ev.data;
            if (!msg || typeof msg !== 'object') return;
            if (msg.type === 'command') {
                if (msg.cmd === 'set' && typeof msg.value === 'number') {
                    timeInput.value = formatSeconds(msg.value);
                    setTimer();
                } else if (msg.cmd === 'start') {
                    if (!timerRunning) toggleTimer();
                } else if (msg.cmd === 'pause') {
                    if (timerRunning) toggleTimer();
                } else if (msg.cmd === 'reset') {
                    resetTimer();
                }
            }
        }
        function initWebRTCUI() {
            const connectDiv = document.createElement('div');
            connectDiv.id = 'connect';
            connectDiv.style.display = 'none'; // Default to hidden
            connectDiv.innerHTML = [
                `<div style='font-size:1.2rem'>跨设备连接 <span id="connection-status" style="font-weight:normal;padding-left:10px;"></span></div>`,
                "<div style='display:flex;flex-wrap:wrap;gap:10px'>",
                "<div style='flex:1 1 450px'>",
                "<div style='margin-bottom:6px'>粘贴控制页提供的 Offer</div>",
                `<input type="text" id='offer-input' placeholder='在此粘贴控制页 Offer'>`,
                "<button id='btn-accept-offer'>接受并生成 Answer</button>",
                "<div style='margin-top:6px'>复制以下 Answer 返回控制页</div>",
                `<input type="text" id='answer-output' placeholder='生成后显示 Answer' readonly>`,
                "</div>",
                "</div>"
            ].join("");
            document.getElementById('controls-wrapper').appendChild(connectDiv);
            
            const connectionStatus = document.getElementById('connection-status');
            function setConnectionStatus(text, color) {
                connectionStatus.textContent = text;
                connectionStatus.style.color = color;
            }
 
            document.getElementById('btn-accept-offer').addEventListener('click', async function() {
                const text = document.getElementById('offer-input').value.trim();
                if (!text) return;
                try {
                    setConnectionStatus('正在连接...', '#888');
                    await setupPeerAsAnswerer(text, setConnectionStatus);
                } catch(e) {
                    setConnectionStatus("连接失败", "#FF6666");
                }
            });

            document.getElementById('btn-toggle-connect').addEventListener('click', () => {
                connectDiv.style.display = connectDiv.style.display === 'none' ? 'flex' : 'none';
            });
        }
        function signalBase(){
            const host = window.location.hostname;
            return `http://${host}:5001`;
        }
        async function postJSON(path, body){
            const rid = roomInput.value.trim();
            const res = await fetch(`${signalBase()}${path}?room=${encodeURIComponent(rid)}`,{
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify(body||{})
            });
            if(!res.ok) throw new Error('network');
            return res.json().catch(()=>({}));
        }
        function subscribeEvents(handler){
            const rid = roomInput.value.trim();
            let stopped = false;
            const poll = async () => {
                if (stopped) return;
                try{
                    const res = await fetch(`${signalBase()}/poll?room=${encodeURIComponent(rid)}&type=offer`, {cache:'no-store'});
                    if(res.ok){
                        const json = await res.json().catch(()=>({}));
                        if(json && !json.empty){
                            handler('offer', json);
                            stopped = true;
                            return;
                        }
                    }
                }catch(_){}
                setTimeout(poll, 1500);
            };
            poll();
            return { stop(){ stopped = true; } };
        }
        async function autoConnectAnswerer(){
            const rid = roomInput.value.trim();
            if(!rid){ statusLabel.textContent = '请填写房间号'; return; }
            const connectionStatus = document.getElementById('connection-status');
            function setConnectionStatus(text, color) {
                if (!connectionStatus) return;
                connectionStatus.textContent = text;
                connectionStatus.style.color = color;
            }
            subscribeEvents(async (type, payload)=>{
                if(type==='offer'){
                    try{
                        pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
                        pc.oniceconnectionstatechange = e => {
                            switch(pc.iceConnectionState) {
                                case "connecting": setConnectionStatus("连接中...", "#66ccff"); break;
                                case "connected": setConnectionStatus("已连接", "#00FF88"); break;
                                case "failed": setConnectionStatus("连接失败", "#FF6666"); break;
                                case "disconnected": setConnectionStatus("连接断开", "#FF6666"); break;
                                case "closed": setConnectionStatus("连接关闭", "#888"); break;
                                default: setConnectionStatus(pc.iceConnectionState, "#888"); break;
                            }
                        };
                        pc.ondatachannel = function(ev) {
                            dc = ev.channel;
                            dc.onmessage = function(ev) {
                                try {
                                    const msg = JSON.parse(ev.data);
                                    if (msg.type === 'command') {
                                        if (msg.cmd === 'set' && typeof msg.value === 'number') {
                                            timeInput.value = formatSeconds(msg.value);
                                            setTimer();
                                        } else if (msg.cmd === 'start') {
                                            if (!timerRunning) toggleTimer();
                                        } else if (msg.cmd === 'pause') {
                                            if (timerRunning) toggleTimer();
                                        } else if (msg.cmd === 'reset') {
                                            resetTimer();
                                        }
                                    }
                                } catch(e) {}
                            };
                        };
                        await pc.setRemoteDescription(payload);
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        await postJSON('/answer', pc.localDescription);
                        setConnectionStatus('Answer 已发布，等待连接', '#888');
                    }catch(e){
                        setConnectionStatus('自动连接失败', '#FF6666');
                    }
                }
            });
        }
        async function setupPeerAsAnswerer(offerText, setConnectionStatus) {
            pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
            
            pc.oniceconnectionstatechange = e => {
                switch(pc.iceConnectionState) {
                    case "connecting": setConnectionStatus("连接中...", "#66ccff"); break;
                    case "connected": setConnectionStatus("已连接", "#00FF88"); break;
                    case "failed": setConnectionStatus("连接失败", "#FF6666"); break;
                    case "disconnected": setConnectionStatus("连接断开", "#FF6666"); break;
                    case "closed": setConnectionStatus("连接关闭", "#888"); break;
                    default: setConnectionStatus(pc.iceConnectionState, "#888"); break;
                }
            };

            pc.ondatachannel = function(ev) {
                dc = ev.channel;
                dc.onmessage = function(ev) {
                    try {
                        const msg = JSON.parse(ev.data);
                        if (msg.type === 'command') {
                            if (msg.cmd === 'set' && typeof msg.value === 'number') {
                                timeInput.value = formatSeconds(msg.value);
                                setTimer();
                            } else if (msg.cmd === 'start') {
                                if (!timerRunning) toggleTimer();
                            } else if (msg.cmd === 'pause') {
                                if (timerRunning) toggleTimer();
                            } else if (msg.cmd === 'reset') {
                                resetTimer();
                            }
                        }
                    } catch(e) {}
                };
                dc.onopen = () => {
                    // Connection confirmed
                };
            };
            pc.onicecandidate = function(ev) {
                if (!ev.candidate) {
                    const answer = pc.localDescription;
                    document.getElementById('answer-output').value = JSON.stringify(answer);
                    // 生成 Answer 分享链接（可选）
                    const encoded = encodeURIComponent(btoa(JSON.stringify(answer)));
                    const shareUrl = `${window.location.origin}/Timer/control.html?answer=${encoded}`;
                    setConnectionStatus('Answer 已生成，请复制或扫码分享', '#888');
                }
            };
            const offer = JSON.parse(offerText);
            await pc.setRemoteDescription(offer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
        }

        // Initialize
        init();

    </script>
</body>
</html>
